diff --git a/Lib/logging/handlers.py b/Lib/logging/handlers.py
index 11ebcf124c..ebf24c8edb 100644
--- a/Lib/logging/handlers.py
+++ b/Lib/logging/handlers.py
@@ -23,7 +23,7 @@ Copyright (C) 2001-2016 Vinay Sajip. All Rights Reserved.
 To use, simply 'import logging.handlers' and log away!
 """
 
-import logging, socket, os, pickle, struct, time, re
+import logging, os, pickle, struct, time, re
 from stat import ST_DEV, ST_INO, ST_MTIME
 import queue
 try:
@@ -482,469 +482,6 @@ class WatchedFileHandler(logging.FileHandler):
         logging.FileHandler.emit(self, record)
 
 
-class SocketHandler(logging.Handler):
-    """
-    A handler class which writes logging records, in pickle format, to
-    a streaming socket. The socket is kept open across logging calls.
-    If the peer resets it, an attempt is made to reconnect on the next call.
-    The pickle which is sent is that of the LogRecord's attribute dictionary
-    (__dict__), so that the receiver does not need to have the logging module
-    installed in order to process the logging event.
-
-    To unpickle the record at the receiving end into a LogRecord, use the
-    makeLogRecord function.
-    """
-
-    def __init__(self, host, port):
-        """
-        Initializes the handler with a specific host address and port.
-
-        When the attribute *closeOnError* is set to True - if a socket error
-        occurs, the socket is silently closed and then reopened on the next
-        logging call.
-        """
-        logging.Handler.__init__(self)
-        self.host = host
-        self.port = port
-        if port is None:
-            self.address = host
-        else:
-            self.address = (host, port)
-        self.sock = None
-        self.closeOnError = False
-        self.retryTime = None
-        #
-        # Exponential backoff parameters.
-        #
-        self.retryStart = 1.0
-        self.retryMax = 30.0
-        self.retryFactor = 2.0
-
-    def makeSocket(self, timeout=1):
-        """
-        A factory method which allows subclasses to define the precise
-        type of socket they want.
-        """
-        if self.port is not None:
-            result = socket.create_connection(self.address, timeout=timeout)
-        else:
-            result = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
-            result.settimeout(timeout)
-            try:
-                result.connect(self.address)
-            except OSError:
-                result.close()  # Issue 19182
-                raise
-        return result
-
-    def createSocket(self):
-        """
-        Try to create a socket, using an exponential backoff with
-        a max retry time. Thanks to Robert Olson for the original patch
-        (SF #815911) which has been slightly refactored.
-        """
-        now = time.time()
-        # Either retryTime is None, in which case this
-        # is the first time back after a disconnect, or
-        # we've waited long enough.
-        if self.retryTime is None:
-            attempt = True
-        else:
-            attempt = (now >= self.retryTime)
-        if attempt:
-            try:
-                self.sock = self.makeSocket()
-                self.retryTime = None # next time, no delay before trying
-            except OSError:
-                #Creation failed, so set the retry time and return.
-                if self.retryTime is None:
-                    self.retryPeriod = self.retryStart
-                else:
-                    self.retryPeriod = self.retryPeriod * self.retryFactor
-                    if self.retryPeriod > self.retryMax:
-                        self.retryPeriod = self.retryMax
-                self.retryTime = now + self.retryPeriod
-
-    def send(self, s):
-        """
-        Send a pickled string to the socket.
-
-        This function allows for partial sends which can happen when the
-        network is busy.
-        """
-        if self.sock is None:
-            self.createSocket()
-        #self.sock can be None either because we haven't reached the retry
-        #time yet, or because we have reached the retry time and retried,
-        #but are still unable to connect.
-        if self.sock:
-            try:
-                self.sock.sendall(s)
-            except OSError: #pragma: no cover
-                self.sock.close()
-                self.sock = None  # so we can call createSocket next time
-
-    def makePickle(self, record):
-        """
-        Pickles the record in binary format with a length prefix, and
-        returns it ready for transmission across the socket.
-        """
-        ei = record.exc_info
-        if ei:
-            # just to get traceback text into record.exc_text ...
-            dummy = self.format(record)
-        # See issue #14436: If msg or args are objects, they may not be
-        # available on the receiving end. So we convert the msg % args
-        # to a string, save it as msg and zap the args.
-        d = dict(record.__dict__)
-        d['msg'] = record.getMessage()
-        d['args'] = None
-        d['exc_info'] = None
-        # Issue #25685: delete 'message' if present: redundant with 'msg'
-        d.pop('message', None)
-        s = pickle.dumps(d, 1)
-        slen = struct.pack(">L", len(s))
-        return slen + s
-
-    def handleError(self, record):
-        """
-        Handle an error during logging.
-
-        An error has occurred during logging. Most likely cause -
-        connection lost. Close the socket so that we can retry on the
-        next event.
-        """
-        if self.closeOnError and self.sock:
-            self.sock.close()
-            self.sock = None        #try to reconnect next time
-        else:
-            logging.Handler.handleError(self, record)
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Pickles the record and writes it to the socket in binary format.
-        If there is an error with the socket, silently drop the packet.
-        If there was a problem with the socket, re-establishes the
-        socket.
-        """
-        try:
-            s = self.makePickle(record)
-            self.send(s)
-        except Exception:
-            self.handleError(record)
-
-    def close(self):
-        """
-        Closes the socket.
-        """
-        self.acquire()
-        try:
-            sock = self.sock
-            if sock:
-                self.sock = None
-                sock.close()
-            logging.Handler.close(self)
-        finally:
-            self.release()
-
-class DatagramHandler(SocketHandler):
-    """
-    A handler class which writes logging records, in pickle format, to
-    a datagram socket.  The pickle which is sent is that of the LogRecord's
-    attribute dictionary (__dict__), so that the receiver does not need to
-    have the logging module installed in order to process the logging event.
-
-    To unpickle the record at the receiving end into a LogRecord, use the
-    makeLogRecord function.
-
-    """
-    def __init__(self, host, port):
-        """
-        Initializes the handler with a specific host address and port.
-        """
-        SocketHandler.__init__(self, host, port)
-        self.closeOnError = False
-
-    def makeSocket(self):
-        """
-        The factory method of SocketHandler is here overridden to create
-        a UDP socket (SOCK_DGRAM).
-        """
-        if self.port is None:
-            family = socket.AF_UNIX
-        else:
-            family = socket.AF_INET
-        s = socket.socket(family, socket.SOCK_DGRAM)
-        return s
-
-    def send(self, s):
-        """
-        Send a pickled string to a socket.
-
-        This function no longer allows for partial sends which can happen
-        when the network is busy - UDP does not guarantee delivery and
-        can deliver packets out of sequence.
-        """
-        if self.sock is None:
-            self.createSocket()
-        self.sock.sendto(s, self.address)
-
-class SysLogHandler(logging.Handler):
-    """
-    A handler class which sends formatted logging records to a syslog
-    server. Based on Sam Rushing's syslog module:
-    http://www.nightmare.com/squirl/python-ext/misc/syslog.py
-    Contributed by Nicolas Untz (after which minor refactoring changes
-    have been made).
-    """
-
-    # from <linux/sys/syslog.h>:
-    # ======================================================================
-    # priorities/facilities are encoded into a single 32-bit quantity, where
-    # the bottom 3 bits are the priority (0-7) and the top 28 bits are the
-    # facility (0-big number). Both the priorities and the facilities map
-    # roughly one-to-one to strings in the syslogd(8) source code.  This
-    # mapping is included in this file.
-    #
-    # priorities (these are ordered)
-
-    LOG_EMERG     = 0       #  system is unusable
-    LOG_ALERT     = 1       #  action must be taken immediately
-    LOG_CRIT      = 2       #  critical conditions
-    LOG_ERR       = 3       #  error conditions
-    LOG_WARNING   = 4       #  warning conditions
-    LOG_NOTICE    = 5       #  normal but significant condition
-    LOG_INFO      = 6       #  informational
-    LOG_DEBUG     = 7       #  debug-level messages
-
-    #  facility codes
-    LOG_KERN      = 0       #  kernel messages
-    LOG_USER      = 1       #  random user-level messages
-    LOG_MAIL      = 2       #  mail system
-    LOG_DAEMON    = 3       #  system daemons
-    LOG_AUTH      = 4       #  security/authorization messages
-    LOG_SYSLOG    = 5       #  messages generated internally by syslogd
-    LOG_LPR       = 6       #  line printer subsystem
-    LOG_NEWS      = 7       #  network news subsystem
-    LOG_UUCP      = 8       #  UUCP subsystem
-    LOG_CRON      = 9       #  clock daemon
-    LOG_AUTHPRIV  = 10      #  security/authorization messages (private)
-    LOG_FTP       = 11      #  FTP daemon
-
-    #  other codes through 15 reserved for system use
-    LOG_LOCAL0    = 16      #  reserved for local use
-    LOG_LOCAL1    = 17      #  reserved for local use
-    LOG_LOCAL2    = 18      #  reserved for local use
-    LOG_LOCAL3    = 19      #  reserved for local use
-    LOG_LOCAL4    = 20      #  reserved for local use
-    LOG_LOCAL5    = 21      #  reserved for local use
-    LOG_LOCAL6    = 22      #  reserved for local use
-    LOG_LOCAL7    = 23      #  reserved for local use
-
-    priority_names = {
-        "alert":    LOG_ALERT,
-        "crit":     LOG_CRIT,
-        "critical": LOG_CRIT,
-        "debug":    LOG_DEBUG,
-        "emerg":    LOG_EMERG,
-        "err":      LOG_ERR,
-        "error":    LOG_ERR,        #  DEPRECATED
-        "info":     LOG_INFO,
-        "notice":   LOG_NOTICE,
-        "panic":    LOG_EMERG,      #  DEPRECATED
-        "warn":     LOG_WARNING,    #  DEPRECATED
-        "warning":  LOG_WARNING,
-        }
-
-    facility_names = {
-        "auth":     LOG_AUTH,
-        "authpriv": LOG_AUTHPRIV,
-        "cron":     LOG_CRON,
-        "daemon":   LOG_DAEMON,
-        "ftp":      LOG_FTP,
-        "kern":     LOG_KERN,
-        "lpr":      LOG_LPR,
-        "mail":     LOG_MAIL,
-        "news":     LOG_NEWS,
-        "security": LOG_AUTH,       #  DEPRECATED
-        "syslog":   LOG_SYSLOG,
-        "user":     LOG_USER,
-        "uucp":     LOG_UUCP,
-        "local0":   LOG_LOCAL0,
-        "local1":   LOG_LOCAL1,
-        "local2":   LOG_LOCAL2,
-        "local3":   LOG_LOCAL3,
-        "local4":   LOG_LOCAL4,
-        "local5":   LOG_LOCAL5,
-        "local6":   LOG_LOCAL6,
-        "local7":   LOG_LOCAL7,
-        }
-
-    #The map below appears to be trivially lowercasing the key. However,
-    #there's more to it than meets the eye - in some locales, lowercasing
-    #gives unexpected results. See SF #1524081: in the Turkish locale,
-    #"INFO".lower() != "info"
-    priority_map = {
-        "DEBUG" : "debug",
-        "INFO" : "info",
-        "WARNING" : "warning",
-        "ERROR" : "error",
-        "CRITICAL" : "critical"
-    }
-
-    def __init__(self, address=('localhost', SYSLOG_UDP_PORT),
-                 facility=LOG_USER, socktype=None):
-        """
-        Initialize a handler.
-
-        If address is specified as a string, a UNIX socket is used. To log to a
-        local syslogd, "SysLogHandler(address="/dev/log")" can be used.
-        If facility is not specified, LOG_USER is used. If socktype is
-        specified as socket.SOCK_DGRAM or socket.SOCK_STREAM, that specific
-        socket type will be used. For Unix sockets, you can also specify a
-        socktype of None, in which case socket.SOCK_DGRAM will be used, falling
-        back to socket.SOCK_STREAM.
-        """
-        logging.Handler.__init__(self)
-
-        self.address = address
-        self.facility = facility
-        self.socktype = socktype
-
-        if isinstance(address, str):
-            self.unixsocket = True
-            # Syslog server may be unavailable during handler initialisation.
-            # C's openlog() function also ignores connection errors.
-            # Moreover, we ignore these errors while logging, so it not worse
-            # to ignore it also here.
-            try:
-                self._connect_unixsocket(address)
-            except OSError:
-                pass
-        else:
-            self.unixsocket = False
-            if socktype is None:
-                socktype = socket.SOCK_DGRAM
-            host, port = address
-            ress = socket.getaddrinfo(host, port, 0, socktype)
-            if not ress:
-                raise OSError("getaddrinfo returns an empty list")
-            for res in ress:
-                af, socktype, proto, _, sa = res
-                err = sock = None
-                try:
-                    sock = socket.socket(af, socktype, proto)
-                    if socktype == socket.SOCK_STREAM:
-                        sock.connect(sa)
-                    break
-                except OSError as exc:
-                    err = exc
-                    if sock is not None:
-                        sock.close()
-            if err is not None:
-                raise err
-            self.socket = sock
-            self.socktype = socktype
-
-    def _connect_unixsocket(self, address):
-        use_socktype = self.socktype
-        if use_socktype is None:
-            use_socktype = socket.SOCK_DGRAM
-        self.socket = socket.socket(socket.AF_UNIX, use_socktype)
-        try:
-            self.socket.connect(address)
-            # it worked, so set self.socktype to the used type
-            self.socktype = use_socktype
-        except OSError:
-            self.socket.close()
-            if self.socktype is not None:
-                # user didn't specify falling back, so fail
-                raise
-            use_socktype = socket.SOCK_STREAM
-            self.socket = socket.socket(socket.AF_UNIX, use_socktype)
-            try:
-                self.socket.connect(address)
-                # it worked, so set self.socktype to the used type
-                self.socktype = use_socktype
-            except OSError:
-                self.socket.close()
-                raise
-
-    def encodePriority(self, facility, priority):
-        """
-        Encode the facility and priority. You can pass in strings or
-        integers - if strings are passed, the facility_names and
-        priority_names mapping dictionaries are used to convert them to
-        integers.
-        """
-        if isinstance(facility, str):
-            facility = self.facility_names[facility]
-        if isinstance(priority, str):
-            priority = self.priority_names[priority]
-        return (facility << 3) | priority
-
-    def close(self):
-        """
-        Closes the socket.
-        """
-        self.acquire()
-        try:
-            self.socket.close()
-            logging.Handler.close(self)
-        finally:
-            self.release()
-
-    def mapPriority(self, levelName):
-        """
-        Map a logging level name to a key in the priority_names map.
-        This is useful in two scenarios: when custom levels are being
-        used, and in the case where you can't do a straightforward
-        mapping by lowercasing the logging level name because of locale-
-        specific issues (see SF #1524081).
-        """
-        return self.priority_map.get(levelName, "warning")
-
-    ident = ''          # prepended to all messages
-    append_nul = True   # some old syslog daemons expect a NUL terminator
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        The record is formatted, and then sent to the syslog server. If
-        exception information is present, it is NOT sent to the server.
-        """
-        try:
-            msg = self.format(record)
-            if self.ident:
-                msg = self.ident + msg
-            if self.append_nul:
-                msg += '\000'
-
-            # We need to convert record level to lowercase, maybe this will
-            # change in the future.
-            prio = '<%d>' % self.encodePriority(self.facility,
-                                                self.mapPriority(record.levelname))
-            prio = prio.encode('utf-8')
-            # Message is a string. Convert to bytes as required by RFC 5424
-            msg = msg.encode('utf-8')
-            msg = prio + msg
-            if self.unixsocket:
-                try:
-                    self.socket.send(msg)
-                except OSError:
-                    self.socket.close()
-                    self._connect_unixsocket(self.address)
-                    self.socket.send(msg)
-            elif self.socktype == socket.SOCK_DGRAM:
-                self.socket.sendto(msg, self.address)
-            else:
-                self.socket.sendall(msg)
-        except Exception:
-            self.handleError(record)
-
 class SMTPHandler(logging.Handler):
     """
     A handler class which sends an SMTP email for each logging event.
diff --git a/Lib/platform.py b/Lib/platform.py
index cc2db9870d..1ec4962abe 100755
--- a/Lib/platform.py
+++ b/Lib/platform.py
@@ -113,7 +113,7 @@ __copyright__ = """
 __version__ = '1.0.8'
 
 import collections
-import sys, os, re, subprocess
+import sys, os, re
 
 import warnings
 
@@ -748,7 +748,7 @@ def _syscmd_uname(option, default=''):
 
     """ Interface to the system's uname command.
     """
-    if sys.platform in ('dos', 'win32', 'win16'):
+    if sys.platform in ('dos', 'win32', 'win16', 'emscripten'):
         # XXX Others too ?
         return default
     try:
@@ -775,6 +775,7 @@ def _syscmd_file(target, default=''):
         # XXX Others too ?
         return default
     target = _follow_symlinks(target)
+    import subprocess
     try:
         proc = subprocess.Popen(['file', target],
                 stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
diff --git a/Lib/test/__init__.py b/Lib/test/__init__.py
index b93054b3ec..cf1b063b86 100644
--- a/Lib/test/__init__.py
+++ b/Lib/test/__init__.py
@@ -1 +1,3 @@
 # Dummy file to make this directory a package.
+import sys
+sys.argv = []
diff --git a/Lib/test/support/__init__.py b/Lib/test/support/__init__.py
index 2930ab24e4..f66da38fd4 100644
--- a/Lib/test/support/__init__.py
+++ b/Lib/test/support/__init__.py
@@ -13,15 +13,12 @@ import gc
 import importlib
 import importlib.util
 import logging.handlers
-import nntplib
 import os
 import platform
 import re
 import shutil
-import socket
 import stat
 import struct
-import subprocess
 import sys
 import sysconfig
 import tempfile
@@ -609,67 +606,10 @@ HOST = "127.0.0.1"
 HOSTv6 = "::1"
 
 
-def find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
-    """Returns an unused port that should be suitable for binding.  This is
-    achieved by creating a temporary socket with the same family and type as
-    the 'sock' parameter (default is AF_INET, SOCK_STREAM), and binding it to
-    the specified host address (defaults to 0.0.0.0) with the port set to 0,
-    eliciting an unused ephemeral port from the OS.  The temporary socket is
-    then closed and deleted, and the ephemeral port is returned.
-
-    Either this method or bind_port() should be used for any tests where a
-    server socket needs to be bound to a particular port for the duration of
-    the test.  Which one to use depends on whether the calling code is creating
-    a python socket, or if an unused port needs to be provided in a constructor
-    or passed to an external program (i.e. the -accept argument to openssl's
-    s_server mode).  Always prefer bind_port() over find_unused_port() where
-    possible.  Hard coded ports should *NEVER* be used.  As soon as a server
-    socket is bound to a hard coded port, the ability to run multiple instances
-    of the test simultaneously on the same host is compromised, which makes the
-    test a ticking time bomb in a buildbot environment. On Unix buildbots, this
-    may simply manifest as a failed test, which can be recovered from without
-    intervention in most cases, but on Windows, the entire python process can
-    completely and utterly wedge, requiring someone to log in to the buildbot
-    and manually kill the affected process.
-
-    (This is easy to reproduce on Windows, unfortunately, and can be traced to
-    the SO_REUSEADDR socket option having different semantics on Windows versus
-    Unix/Linux.  On Unix, you can't have two AF_INET SOCK_STREAM sockets bind,
-    listen and then accept connections on identical host/ports.  An EADDRINUSE
-    OSError will be raised at some point (depending on the platform and
-    the order bind and listen were called on each socket).
-
-    However, on Windows, if SO_REUSEADDR is set on the sockets, no EADDRINUSE
-    will ever be raised when attempting to bind two identical host/ports. When
-    accept() is called on each socket, the second caller's process will steal
-    the port from the first caller, leaving them both in an awkwardly wedged
-    state where they'll no longer respond to any signals or graceful kills, and
-    must be forcibly killed via OpenProcess()/TerminateProcess().
-
-    The solution on Windows is to use the SO_EXCLUSIVEADDRUSE socket option
-    instead of SO_REUSEADDR, which effectively affords the same semantics as
-    SO_REUSEADDR on Unix.  Given the propensity of Unix developers in the Open
-    Source world compared to Windows ones, this is a common mistake.  A quick
-    look over OpenSSL's 0.9.8g source shows that they use SO_REUSEADDR when
-    openssl.exe is called with the 's_server' option, for example. See
-    http://bugs.python.org/issue2550 for more info.  The following site also
-    has a very thorough description about the implications of both REUSEADDR
-    and EXCLUSIVEADDRUSE on Windows:
-    http://msdn2.microsoft.com/en-us/library/ms740621(VS.85).aspx)
-
-    XXX: although this approach is a vast improvement on previous attempts to
-    elicit unused ports, it rests heavily on the assumption that the ephemeral
-    port returned to us by the OS won't immediately be dished back out to some
-    other process when we close and delete our temporary socket but before our
-    calling code has a chance to bind the returned port.  We can deal with this
-    issue if/when we come across it.
-    """
+def find_unused_port(family=None, socktype=None):
+    return 8888
+
 
-    tempsock = socket.socket(family, socktype)
-    port = bind_port(tempsock)
-    tempsock.close()
-    del tempsock
-    return port
 
 def bind_port(sock, host=HOST):
     """Bind the socket to a free port and return the port number.  Relies on
@@ -732,7 +672,7 @@ def _is_ipv6_enabled():
                 sock.close()
     return False
 
-IPV6_ENABLED = _is_ipv6_enabled()
+IPV6_ENABLED = False
 
 def system_must_validate_cert(f):
     """Skip the test on TLS certificate validation failures."""
@@ -1379,6 +1319,8 @@ ioerror_peer_reset = TransientResource(OSError, errno=errno.ECONNRESET)
 def transient_internet(resource_name, *, timeout=30.0, errnos=()):
     """Return a context manager that raises ResourceDenied when various issues
     with the Internet connection manifest themselves as exceptions."""
+    import nntplib, socket
+
     default_errnos = [
         ('ECONNREFUSED', 111),
         ('ECONNRESET', 104),
diff --git a/Lib/test/support/script_helper.py b/Lib/test/support/script_helper.py
index ca5f9c20dd..4e4588dc5e 100644
--- a/Lib/test/support/script_helper.py
+++ b/Lib/test/support/script_helper.py
@@ -7,7 +7,6 @@ import sys
 import os
 import os.path
 import tempfile
-import subprocess
 import py_compile
 import contextlib
 import shutil
@@ -38,6 +37,7 @@ def interpreter_requires_environment():
     variables that might impact whether or not the interpreter can start.
     """
     global __cached_interp_requires_environment
+    import subprocess
     if __cached_interp_requires_environment is None:
         # Try running an interpreter with -E to see if it works or not.
         try:
@@ -165,6 +165,7 @@ def spawn_python(*args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw):
     kw is extra keyword args to pass to subprocess.Popen. Returns a Popen
     object.
     """
+    import subprocess
     cmd_line = [sys.executable, '-E']
     cmd_line.extend(args)
     # Under Fedora (?), GNU readline can output junk on stderr when initialized,
@@ -181,6 +182,7 @@ def spawn_python(*args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw):
 
 def kill_python(p):
     """Run the given Popen process until completion and return stdout."""
+    import subprocess
     p.stdin.close()
     data = p.stdout.read()
     p.stdout.close()
diff --git a/Lib/test/test_bz2.py b/Lib/test/test_bz2.py
index eaa472a6cc..562613314e 100644
--- a/Lib/test/test_bz2.py
+++ b/Lib/test/test_bz2.py
@@ -9,7 +9,6 @@ import glob
 import pathlib
 import random
 import shutil
-import subprocess
 import sys
 from test.support import unlink
 import _compression
@@ -26,13 +25,7 @@ from bz2 import BZ2File, BZ2Compressor, BZ2Decompressor
 has_cmdline_bunzip2 = None
 
 def ext_decompress(data):
-    global has_cmdline_bunzip2
-    if has_cmdline_bunzip2 is None:
-        has_cmdline_bunzip2 = bool(shutil.which('bunzip2'))
-    if has_cmdline_bunzip2:
-        return subprocess.check_output(['bunzip2'], input=data)
-    else:
-        return bz2.decompress(data)
+    return bz2.decompress(data)
 
 class BaseTest(unittest.TestCase):
     "Base for other testcases."
diff --git a/Lib/test/test_capi.py b/Lib/test/test_capi.py
index 6e4286ed88..08bcc853b1 100644
--- a/Lib/test/test_capi.py
+++ b/Lib/test/test_capi.py
@@ -5,7 +5,10 @@ import os
 import pickle
 import random
 import re
-import subprocess
+try:
+    import subprocess
+except ImportError:
+    subprocess = None
 import sys
 import sysconfig
 import textwrap
@@ -51,6 +54,7 @@ class CAPITest(unittest.TestCase):
         self.assertRaises(AttributeError, setattr, inst.testfunction, "attribute", "test")
 
     @unittest.skipUnless(threading, 'Threading required for this test.')
+    @unittest.skipUnless(subprocess, 'subprocess required for this test.')
     def test_no_FatalError_infinite_loop(self):
         with support.SuppressCrashReport():
             p = subprocess.Popen([sys.executable, "-c",
@@ -401,6 +405,7 @@ class EmbeddingTests(unittest.TestCase):
     def tearDown(self):
         os.chdir(self.oldcwd)
 
+    @unittest.skipUnless(subprocess, 'subprocess required for this test.')
     def run_embedded_interpreter(self, *args, env=None):
         """Runs a test in the embedded interpreter"""
         cmd = [self.test_exe]
diff --git a/Lib/test/test_support.py b/Lib/test/test_support.py
index c070809cbe..15f9281d66 100644
--- a/Lib/test/test_support.py
+++ b/Lib/test/test_support.py
@@ -4,7 +4,6 @@ import stat
 import sys
 import os
 import unittest
-import socket
 import tempfile
 import errno
 from test import support
@@ -84,22 +83,22 @@ class TestSupport(unittest.TestCase):
             support.unlink(mod_filename)
             support.rmtree('__pycache__')
 
-    def test_HOST(self):
-        s = socket.socket()
-        s.bind((support.HOST, 0))
-        s.close()
-
-    def test_find_unused_port(self):
-        port = support.find_unused_port()
-        s = socket.socket()
-        s.bind((support.HOST, port))
-        s.close()
-
-    def test_bind_port(self):
-        s = socket.socket()
-        support.bind_port(s)
-        s.listen()
-        s.close()
+    # def test_HOST(self):
+    #     s = socket.socket()
+    #     s.bind((support.HOST, 0))
+    #     s.close()
+
+    # def test_find_unused_port(self):
+    #     port = support.find_unused_port()
+    #     s = socket.socket()
+    #     s.bind((support.HOST, port))
+    #     s.close()
+
+    # def test_bind_port(self):
+    #     s = socket.socket()
+    #     support.bind_port(s)
+    #     s.listen()
+    #     s.close()
 
     # Tests for temp_dir()
 
diff --git a/Lib/unittest/test/test_runner.py b/Lib/unittest/test/test_runner.py
index ddc498c230..b9e809844a 100644
--- a/Lib/unittest/test/test_runner.py
+++ b/Lib/unittest/test/test_runner.py
@@ -2,7 +2,6 @@ import io
 import os
 import sys
 import pickle
-import subprocess
 
 import unittest
 from unittest.case import _Outcome
@@ -280,6 +279,7 @@ class Test_TextTestRunner(unittest.TestCase):
         behavior of the warnings.
         """
         # see #10535 and the _test_warnings file for more information
+        import subprocess
 
         def get_parse_out_err(p):
             return [b.splitlines() for b in p.communicate()]
